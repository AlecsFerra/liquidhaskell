# Local Rewrites Proposal

## The Issue

Suppose we are working with the following Liquid Haskell code:

```haskell
{-@ LIQUID "--ple" @-}
{-@ LIQUID "--reflection" @-}

module Example where

import Language.Haskell.Liquid.ProofCombinators
import Prelude hiding (id)

{-@ reflect id @-}
id :: Int -> Int
id x = x

data Term where
    {-@ MkId :: Prop (Term id) @-}
    MkId :: Term
data TERM = Term (Int -> Int)
```

Parametrizing a type with some value is a common pattern in dependently typed
programming languages.

We would like to prove statements that depend on these parameters.

```haskell
{-@ doSomething :: f:_ -> Prop (Term f) -> {f = id} @-}
doSomething :: (Int -> Int) -> Term -> Proof
doSomething _ MkId = trivial
```

The above passes verification because the SMT solver can easily infer that if
the term was constructed using the `MkId` constructor, then `f = id`.

However, in many cases, this is not enough because there are contexts where the
SMT solver's knowledge is insufficient. Letting PLE unfold `f` can lead to
verification. Consider the following example:

```haskell
{-@ doSomething' :: f:_ -> Prop (Term f) -> {f 42 = 42} @-}
doSomething' :: (Int -> Int) -> Term -> Proof
doSomething' _ MkId = trivial
```

Since for the SMT solver, `f` is still an opaque term (even though it knows that
`f = id`), and PLE doesn't have any equation that states `f = id`, the
verification fails.

This issue could be solved by recognizing that `f` must be equal to `id` when
case-splitting and by informing PLE to expand `f -> id`. However, this expansion
must be local. If we add another constructor to `Term`, `f = id` will not hold
universally.

```haskell
data Term where
    {-@ MkId :: Prop (Term id) @-}
    MkId :: Term
    {-@ MkAny :: f:_ -> Prop (Term f) @-}
    MkAny :: (Int -> Int) -> Term
data TERM = Term (Int -> Int)
```

Currently, the way Liquid Haskell communicates with Liquid Fixpoint, and by
extension PLE, is through the `define` directive. For example, for `id`, it
would generate the following definition:

```fq
define Example.id (x : Int) = {(x)}
```

The issue is that this mechanism is globalâ€”we cannot specify that the rewrite
should occur only in specific subconstraints.

## Possible Solutions

### Solution 1: Modification of Various Frontends (Liquid Haskell)

This proposal suggests the following steps:

- Introduce a mechanism to provide local definitions in the `.fq` file format.
  For example: `define n f = {(Example.id)}`, where `n` is the binding ID that
  contains the equation introducing the rewrite.
  
- Extend the PLE mechanism to account for these local rewrites.
  
- Modify Liquid Haskell to generate such rewrites during the constraint
  generation phase
  (`Liquidhaskell-boot/src/Language/Haskell/Liquid/constraint/Generate.hs`).

**Open Questions:**

- **Horn Format:** The Horn format would also need modifications, especially
  since bindings are not listed globally in the `.fq` format but appear inline
  with the constraints. We currently have no way to refer to constraints
  unambiguously. One possible solution is to introduce a new expression type
  like `(localRewrite f Example.id bar)`, where `bar` is the expression in which
  the rewrite can occur.

- Implementing this would cause code duplication across various frontends, as
  unification logic and infinite loop checks would have to be repeated.

### Solution 2: Modification of Liquid Fixpoint

This proposal suggests the following steps:

- Extract the rewrites during the construction of the bindings (in the
  `withAssm` function in `PLE.hs`) by inspecting each binding to determine if it
  was generated by a case split and extracting equalities in the same way as
  described in Solution 1.

**Challenges:**

- We need a uniform way to distinguish whether a variable is "local" (i.e., a
  variable without a definition, like a function parameter). An earlier attempt
  at this was part of PR 
  [#705](https://github.com/ucsd-progsys/liquid-fixpoint/pull/705), but it was 
  removed because the solution was too dependent on the variable naming scheme
  used by Liquid Haskell. This in LH is a non issue as GHC Variables are 
  annotated with extra information.
